<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <title>2048 — EXECPT ITS GREEK LETTERS INSTEAD</title>
  <style>
    /* Exact requested palette + adjustments for screenshot look */
    :root{
      --bg: #F3C10A;           /* page background (exact) */
      --accent-dark: #114922;  /* dark green accent (exact) */
      --score-bg: #E3FF6C;     /* pale lime for score (exact) */

      --tile-size: 96px;
      --gap: 18px;
      --board-padding: 18px;
      --board-radius: 12px;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:300;color:var(--accent-dark);
      /* Prevent text selection and touch callouts on mobile */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{max-width:760px;margin:28px auto;padding:0 18px}
    .header{display:flex;justify-content:space-between;align-items:center}
    .title{font-size:96px;line-height:0.9;font-weight:200;margin:0;letter-spacing:-2px}
    .subtitle{font-size:12px;color:rgba(17,73,34,0.65);letter-spacing:1px;margin-top:6px}

    .scores{display:flex;gap:12px;align-items:center}
    .score-box{background:var(--score-bg);padding:10px 14px;border-radius:8px;box-shadow:inset 0 -4px 0 rgba(0,0,0,0.04);text-align:center}
    .score-box .label{font-size:11px;color:var(--accent-dark);letter-spacing:1px}
    .score-box .value{font-size:22px;font-weight:700;color:var(--accent-dark)}

    /* board area */
    .board-wrap{margin:18px auto 0 auto;background:transparent;padding:var(--board-padding);border-radius:var(--board-radius);border:3px solid rgba(0,0,0,0.08);box-shadow:0 6px 0 rgba(0,0,0,0.03) inset;display:flex;justify-content:center;align-items:center;
      /* Make touch area more responsive */
      touch-action: none;
      -webkit-touch-callout: none;
    }
    .slot-grid{width: calc((var(--tile-size) * 4) + (var(--gap) * 3)); height: calc((var(--tile-size) * 4) + (var(--gap) * 3)); position:relative}
    .slot{position:absolute;width:var(--tile-size);height:var(--tile-size);background:rgba(255,255,255,0.06);border-radius:8px}

    /* tile visuals — colors approximate screenshot greens but feel progressive */
    .tile{position:absolute;width:var(--tile-size);height:var(--tile-size);border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 6px 0 rgba(0,0,0,0.06);transition:transform 300ms cubic-bezier(.2,.6,.2,1), background-color 200ms}
    .tile .letter{font-size:48px;line-height:1;color:inherit}
    .tile.pop{animation: pop 220ms ease-out}
    @keyframes pop{0%{transform:scale(.4)}60%{transform:scale(1.08)}100%{transform:scale(1)}}

    /* exact-ish green palette matching screenshot progression (light -> dark) */
    .t-a{background:#E9F99D;color:#243b0f} /* α (2) */
    .t-b{background:#E6F77F;color:#243b0f} /* β (4) */
    .t-g{background:#CDE84A;color:#243b0f} /* γ (8) */
    .t-d{background:#9FBD2A;color:#eaf6b9} /* δ (16) */
    .t-e{background:#84A81E;color:#e9f7b1} /* ε (32) */
    .t-z{background:#6B8E17;color:#e2f0a0} /* ζ (64) */
    .t-h{background:#4C6B10;color:#d9e893} /* η (128) */
    .t-i{background:#2E3F09;color:#d1e07f} /* θ (256) */
    .t-j{background:#1F2B06;color:#c9d96b} /* ι (512) */
    .t-k{background:#151D04;color:#c1d257} /* κ (1024) */
    .t-l{background:#0D1302;color:#b9cb43} /* λ (2048) */
    .t-m{background:#070B01;color:#b1c42f} /* μ (4096) */
    .t-n{background:#030500;color:#a9bd1b} /* ν (8192) */

    .controls{display:flex;align-items:center;justify-content:space-between;margin-top:14px}
    .btn{background:var(--accent-dark);color:var(--score-bg);padding:12px 30px;border-radius:6px;border:3px solid rgba(0,0,0,0.06);font-weight:400;font-size:16px;cursor:pointer;white-space:nowrap;border:none}
    .hint{color:rgba(17,73,34,0.75);font-size:13px}

    footer{margin-top:8px;color:rgba(17,73,34,0.6);font-size:12px;text-align:center}

    /* Player form overlay */
    .player-form-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:1000}
    .player-form-content{background:var(--bg);padding:30px;border-radius:12px;border:3px solid rgba(0,0,0,0.1);box-shadow:0 10px 30px rgba(0,0,0,0.3);max-width:400px;width:90%}
    .player-form-content h2{margin:0 0 20px 0;color:var(--accent-dark);text-align:center;font-size:24px}
    .form-group{margin-bottom:15px}
    .form-group label{display:block;margin-bottom:5px;color:var(--accent-dark);font-weight:500}
    .form-group input{width:100%;padding:10px;border:2px solid rgba(17,73,34,0.2);border-radius:6px;font-size:16px;color:var(--accent-dark);-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}
    .form-group input:focus{outline:none;border-color:var(--accent-dark)}
    .form-buttons{display:flex;gap:10px;margin-top:20px;flex-wrap:wrap}
    .btn-secondary{background:rgba(17,73,34,0.1);color:var(--accent-dark);padding:12px 20px;border-radius:6px;border:2px solid rgba(17,73,34,0.2);font-weight:400;cursor:pointer;flex:1;min-width:120px;text-align:center;border:none}
    .btn-secondary:hover{background:rgba(17,73,34,0.2)}

    /* overlay game over */
  .overlay{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(243,193,10,0.96);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--board-radius);padding:24px;z-index:1001;max-width:90vw;min-width:260px;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
    .overlay h2{font-size:32px;margin:0;color:var(--accent-dark)}
    .overlay p{color:var(--accent-dark);margin:8px 0}

    /* win overlay - different styling for victory */
  .win-overlay{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(17,73,34,0.95);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--board-radius);padding:24px;z-index:1001;max-width:90vw;min-width:260px;box-shadow:0 10px 30px rgba(0,0,0,0.3)}
    .win-overlay h2{font-size:32px;margin:0;color:var(--score-bg)}
    .win-overlay p{color:var(--score-bg);margin:8px 0;text-align:center}

  /* Prevent overlay buttons from inheriting mobile flex growth */
  .overlay .btn, .win-overlay .btn{flex:0;align-self:center;max-width:240px;width:auto}

    @media (max-width:840px){ 
      .title{font-size:48px} 
      .subtitle{font-size:10px}
      
      /* Center content vertically and horizontally on mobile */
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 10px 0;
      }
      
      .wrap{padding:8px; max-width:100%; margin:0 auto} 
      .header{flex-direction:row; justify-content:space-between; align-items:center; margin-bottom:15px}
      .scores{margin-top:0; gap:8px}
      .score-box{padding:6px 10px}
      .score-box .label{font-size:9px}
      .score-box .value{font-size:16px}
      
      /* Mobile board adjustments - keep similar proportions */
      :root{
        --tile-size: 60px;
        --gap: 10px;
        --board-padding: 10px;
      }
      
      .board-wrap{margin:15px auto 0 auto; padding:var(--board-padding)}
      .tile .letter{font-size:28px}
      
      /* Mobile controls */
      .controls{margin-top:15px; align-items:flex-start}
      .btn{font-size:12px; padding:8px 16px; white-space:nowrap}
      .hint{text-align:right; margin-left:15px; font-size:10px; line-height:1.3}
      
      /* Mobile form */
      .player-form-content{padding:20px; max-width:85%; margin:0 auto}
      .player-form-content h2{font-size:20px; margin-bottom:15px}
      .form-group{margin-bottom:12px}
      .form-group label{font-size:14px; margin-bottom:4px}
      .form-group input{font-size:16px; padding:10px}
      .form-buttons{margin-top:15px; gap:8px; flex-direction:row}
      .btn-secondary{padding:10px 16px; font-size:12px; min-width:auto; flex:1}
      .btn{flex:2; margin-bottom:0}
      
      footer{font-size:10px; margin-top:15px}
      
      /* Win/Game Over overlays for mobile */
      .overlay h2, .win-overlay h2{font-size:24px}
      .overlay p, .win-overlay p{font-size:14px}
      .overlay .btn, .win-overlay .btn{font-size:12px; padding:8px 16px}
    }

    /* Extra small screens (phones in portrait) */
    @media (max-width:480px) {
      .title{font-size:40px}
      
      /* Maintain vertical and horizontal centering */
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 5px 0;
      }
      
      .wrap{margin:0 auto; padding:6px}
      .header{margin-bottom:12px}
      .scores{gap:6px}
      .score-box{padding:5px 8px}
      .score-box .value{font-size:14px}
      
      :root{
        --tile-size: 55px;
        --gap: 8px;
        --board-padding: 8px;
      }
      
      .board-wrap{margin:12px auto 0 auto}
      .tile .letter{font-size:24px}
      .controls{margin-top:12px}
      .btn{padding:6px 12px; font-size:11px}
      .hint{font-size:9px; margin-left:10px}
      footer{font-size:9px; margin-top:12px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div>
        <h1 class="title" style="font-family:inherit; letter-spacing:0;">2048</h1>
        <div class="subtitle" style="font-family:inherit; letter-spacing:0;">EXCEPT ITS GREEK LETTERS INSTEAD.</div>
      </div>
      <div class="scores">
        <div class="score-box"><div class="label">SCORE</div><div id="score" class="value">0</div></div>
        <div class="score-box"><div class="label">BEST</div><div id="high" class="value">0</div></div>
      </div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <div id="board" class="slot-grid"></div>
    </div>

    <!-- Player Registration Form -->
    <div id="player-form" class="player-form-overlay" style="display:none;">
      <div class="player-form-content">
        <h2>Fill Your Identity First!</h2>
        <div class="form-group">
          <label>Full Name:</label>
          <input type="text" id="player-name" required autocomplete="name" />
        </div>
        <div class="form-group">
          <label>Year (Angkatan):</label>
          <input type="text" id="player-year" required autocomplete="off" />
        </div>
        <div class="form-buttons">
          <button id="start-game" class="btn">Start Game</button>
          <button id="cancel-form" class="btn-secondary">Cancel</button>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="newBtn" class="btn">START NEW GAME</button>
      <div class="hint" style="text-align:right; margin-left: 60px;">Use arrow keys or swipe to move tiles. You are free to play, but your score will only be recorded in the first 3 attempts. Enjoy playing!</div>
    </div>

    <footer>Presented by Mistikus, only for you.</footer>
  </div>

<script>
// Game logic — strict Greek sequence mapping (2->α, 4->β, 8->γ, ...)
const SIZE = 4;
const ANIM_MS = 300; const POP_MS = 220;
let grid = null, score = 0, high = 0, lastAdded = null;
// Busy flag prevents queuing new moves while an animation is running
let busy = false;
const boardEl = document.getElementById('board'); const scoreEl = document.getElementById('score'); const highEl = document.getElementById('high'); const newBtn = document.getElementById('newBtn');

// Get current tile size and gap from CSS variables
function getTileSize() {
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size'));
}

function getGap() {
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
}

// Player registration variables
let playerName = '';
let playerYear = '';
const playerFormEl = document.getElementById('player-form');
const playerNameEl = document.getElementById('player-name');
const playerYearEl = document.getElementById('player-year');
const startGameBtn = document.getElementById('start-game');
const cancelFormBtn = document.getElementById('cancel-form');

// Formspree endpoint
const FORMSPREE_ENDPOINT = 'https://formspree.io/f/xeorjqqe';

const GREEK = ['','α','β','γ','δ','ε','ζ','η','θ','ι','κ','λ','μ','ν'];
function makeEmptyGrid(){ return Array.from({length:SIZE}, ()=>Array(SIZE).fill(0)); }
function copyGrid(g){ return g.map(r=>r.slice()); }
function valueToIndex(val){ let idx=0; while(val>1){ val/=2; idx++; } return idx; }
function letterFor(value){ if(value===0) return ''; return GREEK[valueToIndex(value)] || String(value); }
function clsFor(value){ if(value===0) return ''; const idx = valueToIndex(value); const map = ['','t-a','t-b','t-g','t-d','t-e','t-z','t-h','t-i','t-j','t-k','t-l','t-m','t-n']; return map[idx] || 't-n'; }

function renderSlots(){ 
  boardEl.innerHTML=''; 
  const TILE = getTileSize();
  const GAP = getGap();
  const total = (TILE * SIZE) + (GAP*(SIZE-1)); 
  boardEl.style.width = total + 'px'; 
  boardEl.style.height = total + 'px';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const s = document.createElement('div'); 
      s.className='slot'; 
      s.style.left = (c*(TILE+GAP)) + 'px'; 
      s.style.top = (r*(TILE+GAP)) + 'px'; 
      boardEl.appendChild(s);
    }
  }
}

function createTileEl(value, r, c){ 
  const TILE = getTileSize();
  const GAP = getGap();
  const el = document.createElement('div'); 
  el.className = 'tile '+clsFor(value); 
  el.style.left = (c*(TILE+GAP)) + 'px'; 
  el.style.top = (r*(TILE+GAP)) + 'px'; 
  el.dataset.r=r; 
  el.dataset.c=c; 
  const letter = document.createElement('div'); 
  letter.className='letter'; 
  letter.textContent = letterFor(value); 
  el.appendChild(letter); 
  return el; 
}

function render(){ Array.from(boardEl.querySelectorAll('.tile')).forEach(x=>x.remove()); for(let r=0;r<SIZE;r++){ for(let c=0;c<SIZE;c++){ const v = grid[r][c]; if(v!==0){ const el = createTileEl(v,r,c); if(lastAdded && lastAdded.r===r && lastAdded.c===c){ el.classList.add('pop'); setTimeout(()=>el.classList.remove('pop'), POP_MS+20); } boardEl.appendChild(el); } } } }

function moveLeftPure(g){ const n=SIZE; const newG = makeEmptyGrid(); let moved=false; let gained=0; for(let r=0;r<n;r++){ const row = g[r].filter(x=>x!==0); const mergedRow=[]; for(let i=0;i<row.length;i++){ if(i+1<row.length && row[i]===row[i+1]){ mergedRow.push(row[i]*2); gained += row[i]*2; i++; } else mergedRow.push(row[i]); } for(let c=0;c<mergedRow.length;c++) newG[r][c]=mergedRow[c]; for(let c=mergedRow.length;c<n;c++) newG[r][c]=0; if(newG[r].toString() !== g[r].toString()) moved=true; } return {grid:newG,moved,gained}; }
function rotateCW(g){ const n=SIZE; const out = makeEmptyGrid(); for(let r=0;r<n;r++) for(let c=0;c<n;c++) out[c][n-1-r]=g[r][c]; return out; }
function simulateMove(g, dir){ const map={left:0,up:3,right:2,down:1}; const times = map[dir]||0; let working = copyGrid(g); for(let i=0;i<times;i++) working = rotateCW(working); const res = moveLeftPure(working); for(let i=0;i<(4-times)%4;i++) res.grid = rotateCW(res.grid); return res; }

function buildMovements(oldGrid,newGrid,dir){ const movs=[]; if(dir==='left' || dir==='right'){ for(let r=0;r<SIZE;r++){ const olds=[]; for(let c=0;c<SIZE;c++) if(oldGrid[r][c]!==0) olds.push({val:oldGrid[r][c],c}); const news=[]; for(let c=0;c<SIZE;c++) if(newGrid[r][c]!==0) news.push({val:newGrid[r][c],c}); for(let i=0;i<olds.length;i++){ const from=[r,olds[i].c]; const to = news[i] ? [r,news[i].c] : from; const merged = (news[i] && news[i].val !== olds[i].val); movs.push({from,to,value:olds[i].val,merged}); } } } else { for(let c=0;c<SIZE;c++){ const olds=[]; for(let r=0;r<SIZE;r++) if(oldGrid[r][c]!==0) olds.push({val:oldGrid[r][c],r}); const news=[]; for(let r=0;r<SIZE;r++) if(newGrid[r][c]!==0) news.push({val:newGrid[r][c],r}); for(let i=0;i<olds.length;i++){ const from=[olds[i].r,c]; const to = news[i] ? [news[i].r,c] : from; const merged = (news[i] && news[i].val !== olds[i].val); movs.push({from,to,value:olds[i].val,merged}); } } } return movs; }

function animateMove(movements, callback){ 
  if(!movements || movements.length===0){ 
    if(callback) callback(); 
    return; 
  } 
  // mark busy while animating
  busy = true;
  const TILE = getTileSize();
  const GAP = getGap();
  const tempEls=[]; 
  movements.forEach(m=>{ 
    const el = createTileEl(m.value, m.from[0], m.from[1]); 
    el.style.zIndex=20; 
    boardEl.appendChild(el); 
    const dx=(m.to[1]-m.from[1])*(TILE+GAP); 
    const dy=(m.to[0]-m.from[0])*(TILE+GAP); 
    requestAnimationFrame(()=>{ 
      el.style.transform = `translate(${dx}px, ${dy}px)`; 
    }); 
    tempEls.push({el,merged:m.merged,to:m.to}); 
  }); 
  setTimeout(()=>{ 
    tempEls.forEach(t=>t.el.remove()); 
    if(callback) callback(); 
    // clear busy after animation completes
    busy = false;
  }, ANIM_MS+40); 
}

function doPopOnMerged(oldG,newG){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){ const ov=oldG[r][c]||0, nv=newG[r][c]||0; if(nv!==0 && nv!==ov){ const el = Array.from(boardEl.querySelectorAll('.tile')).find(x=>Number(x.dataset.r)===r && Number(x.dataset.c)===c && x.querySelector('.letter').textContent===letterFor(nv)); if(el){ el.style.transform='scale(.9)'; setTimeout(()=>el.style.transform='scale(1)', POP_MS+20); } } } }

function applyMove(dir){ 
  if(!grid) return; 
  if(busy) return; // ignore moves while animating
  const old = copyGrid(grid); 
  const res = simulateMove(old,dir); 
  if(!res.moved) return; 
  const movements = buildMovements(old,res.grid,dir); 
  animateMove(movements, ()=>{ 
    grid = res.grid; 
    setScore(score + res.gained); 
    addRandomTile(); 
    render(); 
    doPopOnMerged(old,grid); 
    if(hasWon(grid)) showWinOverlay(); 
    else if(!canMove(grid)) showGameOverOverlay(); 
  }); 
}

function randTile(){ const r=Math.random(); if(r<0.70) return 2; if(r<0.95) return 4; return 8; }
function addRandomTile(){ const empties=[]; for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(grid[r][c]===0) empties.push([r,c]); if(empties.length===0) return false; const [r,c] = empties[Math.floor(Math.random()*empties.length)]; grid[r][c]=randTile(); lastAdded={r,c,ts:performance.now()}; return true; }

function canMove(g){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(g[r][c]===0) return true; for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE-1;c++) if(g[r][c]===g[r][c+1]) return true; for(let c=0;c<SIZE;c++) for(let r=0;r<SIZE-1;r++) if(g[r][c]===g[r+1][c]) return true; return false; }

function hasWon(g){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(g[r][c]>=8192) return true; return false; }

function setScore(v){ score=v; scoreEl.textContent=score; if(score>high){ high=score; try{ localStorage.setItem('greek-high', high); }catch(e){} highEl.textContent=high; } }

// Send player data to Formspree
async function sendPlayerData(playerName, playerYear, finalScore) {
  try {
    const response = await fetch(FORMSPREE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: playerName,
        year: playerYear,
        score: finalScore,
        timestamp: new Date().toISOString()
      })
    });
    
    if (response.ok) {
      console.log('Player data sent successfully');
    } else {
      console.error('Failed to send player data');
    }
  } catch (error) {
    console.error('Error sending player data:', error);
  }
}

function showGameOverOverlay(){ 
  if(document.querySelector('.overlay') || document.querySelector('.win-overlay')) return; 
  
  // Send player data to Formspree if player is registered
  if(playerName && playerYear) {
    sendPlayerData(playerName, playerYear, score);
  }
  
  const ov=document.createElement('div'); 
  ov.className='overlay'; 
  const h=document.createElement('h2'); 
  h.textContent='Game Over'; 
  const p=document.createElement('p'); 
  p.textContent='Score: '+score; 
  const btn=document.createElement('button'); 
  btn.className='btn'; 
  btn.textContent='Try Again'; 
  btn.onclick=()=>{ ov.remove(); showPlayerForm(); }; 
  ov.appendChild(h); 
  ov.appendChild(p); 
  ov.appendChild(btn); 
  boardEl.parentElement.appendChild(ov); 
}

function showWinOverlay(){ 
  if(document.querySelector('.overlay') || document.querySelector('.win-overlay')) return; 
  
  // Send player data to Formspree if player is registered
  if(playerName && playerYear) {
    sendPlayerData(playerName, playerYear, score);
  }
  
  const ov=document.createElement('div'); 
  ov.className='win-overlay'; 
  const h=document.createElement('h2'); 
  h.textContent='CONGRATULATIONS!'; 
  const p=document.createElement('p'); 
  p.textContent='You are good at this huh.'; 
  const scoreP=document.createElement('p'); 
  scoreP.textContent='Final Score: '+score; 
  const btn=document.createElement('button'); 
  btn.className='btn'; 
  btn.textContent='Play Again'; 
  btn.onclick=()=>{ ov.remove(); showPlayerForm(); }; 
  ov.appendChild(h); 
  ov.appendChild(p); 
  ov.appendChild(scoreP); 
  ov.appendChild(btn); 
  boardEl.parentElement.appendChild(ov); 
}

// Player registration functions
function showPlayerForm() {
  playerFormEl.style.display = 'flex';
  playerNameEl.value = '';
  playerYearEl.value = '';
  
  // Initialize button state - start with disabled
  startGameBtn.style.opacity = '0.7';
  startGameBtn.style.background = 'rgba(17,73,34,0.7)';
  startGameBtn.style.pointerEvents = 'none';
  
  // Enable input fields for mobile
  playerNameEl.removeAttribute('disabled');
  playerYearEl.removeAttribute('disabled');
  playerNameEl.style.pointerEvents = 'auto';
  playerYearEl.style.pointerEvents = 'auto';
}

function hidePlayerForm() {
  playerFormEl.style.display = 'none';
}

function validateAndStartGame() {
  const name = playerNameEl.value.trim();
  const year = playerYearEl.value.trim();
  
  if (!name || !year) {
    // Instead of alert, show a gentle warning
    showFormWarning('Please fill in both Full Name and Year fields');
    return;
  }
  
  playerName = name;
  playerYear = year;
  hidePlayerForm();
  startNewGame();
}

function showFormWarning(message) {
  // Create a temporary warning message
  const existing = document.querySelector('.form-warning');
  if (existing) existing.remove();
  
  const warning = document.createElement('div');
  warning.className = 'form-warning';
  warning.textContent = message;
  warning.style.cssText = `
    color: #d32f2f;
    font-size: 12px;
    margin-top: 8px;
    text-align: center;
  `;
  
  const formContent = document.querySelector('.player-form-content');
  formContent.appendChild(warning);
  
  // Remove warning after 3 seconds
  setTimeout(() => {
    if (warning.parentNode) warning.remove();
  }, 3000);
}

// input
document.addEventListener('keydown', e=>{ if(!grid) return; if(e.key==='ArrowLeft'){ e.preventDefault(); applyMove('left'); } else if(e.key==='ArrowRight'){ e.preventDefault(); applyMove('right'); } else if(e.key==='ArrowUp'){ e.preventDefault(); applyMove('up'); } else if(e.key==='ArrowDown'){ e.preventDefault(); applyMove('down'); } });

// Enhanced touch controls for mobile
let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
let mouseStartX = 0, mouseStartY = 0, mouseEndX = 0, mouseEndY = 0;
let isMouseDown = false;
const minSwipeDistance = 30;

// Prevent scrolling and zooming on the game board
boardEl.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}, { passive: false });

boardEl.addEventListener('touchmove', e => {
  e.preventDefault(); // Prevent scrolling
}, { passive: false });

boardEl.addEventListener('touchend', e => {
  e.preventDefault();
  if (!grid) return;
  if (busy) return; // ignore touch input while animating
  
  const touch = e.changedTouches[0];
  touchEndX = touch.clientX;
  touchEndY = touch.clientY;
  
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  const absDeltaX = Math.abs(deltaX);
  const absDeltaY = Math.abs(deltaY);
  
  // Only process swipe if it's long enough
  if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) return;
  
  // Determine swipe direction
  if (absDeltaX > absDeltaY) {
    // Horizontal swipe
    if (deltaX > 0) {
      applyMove('right');
    } else {
      applyMove('left');
    }
  } else {
    // Vertical swipe
    if (deltaY > 0) {
      applyMove('down');
    } else {
      applyMove('up');
    }
  }
}, { passive: false });

// Mouse swipe controls for desktop
boardEl.addEventListener('mousedown', e => {
  if (!grid) return;
  e.preventDefault();
  isMouseDown = true;
  mouseStartX = e.clientX;
  mouseStartY = e.clientY;
  boardEl.style.cursor = 'grabbing';
});

boardEl.addEventListener('mousemove', e => {
  if (!isMouseDown) return;
  e.preventDefault();
});

boardEl.addEventListener('mouseup', e => {
  if (!isMouseDown || !grid) return;
  e.preventDefault();
  if (busy) return; // ignore mouse input while animating
  
  isMouseDown = false;
  boardEl.style.cursor = 'grab';
  
  mouseEndX = e.clientX;
  mouseEndY = e.clientY;
  
  const deltaX = mouseEndX - mouseStartX;
  const deltaY = mouseEndY - mouseStartY;
  const absDeltaX = Math.abs(deltaX);
  const absDeltaY = Math.abs(deltaY);
  
  // Only process swipe if it's long enough
  if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) return;
  
  // Determine swipe direction
  if (absDeltaX > absDeltaY) {
    // Horizontal swipe
    if (deltaX > 0) {
      applyMove('right');
    } else {
      applyMove('left');
    }
  } else {
    // Vertical swipe
    if (deltaY > 0) {
      applyMove('down');
    } else {
      applyMove('up');
    }
  }
});

// Handle mouse leave to reset state
boardEl.addEventListener('mouseleave', e => {
  if (isMouseDown) {
    isMouseDown = false;
    boardEl.style.cursor = 'grab';
  }
});

// Set initial cursor style
boardEl.style.cursor = 'grab';

// Prevent default touch behaviors on the entire game area
document.addEventListener('touchstart', e => {
  // Allow touch events on form inputs and buttons
  if (e.target.closest('.form-group input') || e.target.closest('.btn') || e.target.closest('.btn-secondary')) {
    return; // Don't prevent default for form elements
  }
  if (e.target.closest('.board-wrap') || e.target.closest('.player-form-overlay')) {
    e.preventDefault();
  }
}, { passive: false });

// Add viewport meta tag programmatically for better mobile experience
if (!document.querySelector('meta[name="viewport"]')) {
  const viewport = document.createElement('meta');
  viewport.name = 'viewport';
  viewport.content = 'width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0';
  document.head.appendChild(viewport);
}

// lifecycle
function startNewGame(){ grid=makeEmptyGrid(); setScore(0); renderSlots(); addRandomTile(); addRandomTile(); render(); }

// Event listeners
newBtn.addEventListener('click', ()=> showPlayerForm());
startGameBtn.addEventListener('click', validateAndStartGame);
cancelFormBtn.addEventListener('click', hidePlayerForm);

// Real-time form validation - no Enter key required
playerNameEl.addEventListener('input', checkFormCompletion);
playerYearEl.addEventListener('input', checkFormCompletion);

// Make sure form inputs work on mobile
playerNameEl.addEventListener('touchstart', (e) => {
  e.stopPropagation(); // Prevent event bubbling
});

playerYearEl.addEventListener('touchstart', (e) => {
  e.stopPropagation(); // Prevent event bubbling
});

startGameBtn.addEventListener('touchstart', (e) => {
  e.stopPropagation(); // Prevent event bubbling
});

cancelFormBtn.addEventListener('touchstart', (e) => {
  e.stopPropagation(); // Prevent event bubbling
});

// Auto-enable start button when both fields have content
function checkFormCompletion() {
  const name = playerNameEl.value.trim();
  const year = playerYearEl.value.trim();
  
  if (name && year) {
    startGameBtn.style.opacity = '1';
    startGameBtn.style.background = 'var(--accent-dark)';
    startGameBtn.style.pointerEvents = 'auto';
    startGameBtn.removeAttribute('disabled');
  } else {
    startGameBtn.style.opacity = '0.7';
    startGameBtn.style.background = 'rgba(17,73,34,0.7)';
    startGameBtn.style.pointerEvents = 'none';
    startGameBtn.setAttribute('disabled', 'true');
  }
}

window.addEventListener('load', ()=>{ 
  high = parseInt(localStorage.getItem('greek-high')||'0',10) || 0; 
  highEl.textContent = high; 
  renderSlots(); 
  // Don't auto-start game, wait for player registration
});

// debug
window._dumpGrid = ()=>grid; 
</script>
</body>
</html>
